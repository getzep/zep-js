/**
 * This file was auto-generated by Fern from our API Definition.
 */

import { mockServerPool } from "../mock-server/MockServerPool";
import { ZepClient } from "../../src/Client";

describe("Graph", () => {
    test("list_entity_types", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            edge_types: [
                {
                    description: "description",
                    name: "name",
                    properties: [{ description: "description", name: "name", type: "Text" }],
                    source_targets: [{}],
                },
            ],
            entity_types: [
                {
                    description: "description",
                    name: "name",
                    properties: [{ description: "description", name: "name", type: "Text" }],
                },
            ],
        };
        server.mockEndpoint().get("/entity-types").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.graph.listEntityTypes({
            userId: "user_id",
            graphId: "graph_id",
        });
        expect(response).toEqual({
            edgeTypes: [
                {
                    description: "description",
                    name: "name",
                    properties: [
                        {
                            description: "description",
                            name: "name",
                            type: "Text",
                        },
                    ],
                    sourceTargets: [{}],
                },
            ],
            entityTypes: [
                {
                    description: "description",
                    name: "name",
                    properties: [
                        {
                            description: "description",
                            name: "name",
                            type: "Text",
                        },
                    ],
                },
            ],
        });
    });

    test("set_entity_types_internal", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { message: "message" };
        server
            .mockEndpoint()
            .put("/entity-types")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.graph.setEntityTypesInternal();
        expect(response).toEqual({
            message: "message",
        });
    });

    test("add", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { data: "data", type: "text" };
        const rawResponseBody = {
            content: "content",
            created_at: "created_at",
            metadata: { key: "value" },
            processed: true,
            relevance: 1.1,
            role: "role",
            role_type: "norole",
            score: 1.1,
            source: "text",
            source_description: "source_description",
            task_id: "task_id",
            thread_id: "thread_id",
            uuid: "uuid",
        };
        server
            .mockEndpoint()
            .post("/graph")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.graph.add({
            data: "data",
            type: "text",
        });
        expect(response).toEqual({
            content: "content",
            createdAt: "created_at",
            metadata: {
                key: "value",
            },
            processed: true,
            relevance: 1.1,
            role: "role",
            roleType: "norole",
            score: 1.1,
            source: "text",
            sourceDescription: "source_description",
            taskId: "task_id",
            threadId: "thread_id",
            uuid: "uuid",
        });
    });

    test("add_batch", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { episodes: [{ data: "data", type: "text" }] };
        const rawResponseBody = [
            {
                content: "content",
                created_at: "created_at",
                metadata: { key: "value" },
                processed: true,
                relevance: 1.1,
                role: "role",
                role_type: "norole",
                score: 1.1,
                source: "text",
                source_description: "source_description",
                task_id: "task_id",
                thread_id: "thread_id",
                uuid: "uuid",
            },
        ];
        server
            .mockEndpoint()
            .post("/graph-batch")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.graph.addBatch({
            episodes: [
                {
                    data: "data",
                    type: "text",
                },
            ],
        });
        expect(response).toEqual([
            {
                content: "content",
                createdAt: "created_at",
                metadata: {
                    key: "value",
                },
                processed: true,
                relevance: 1.1,
                role: "role",
                roleType: "norole",
                score: 1.1,
                source: "text",
                sourceDescription: "source_description",
                taskId: "task_id",
                threadId: "thread_id",
                uuid: "uuid",
            },
        ]);
    });

    test("add_fact_triple", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            fact: "fact",
            fact_name: "fact_name",
            source_node_name: "source_node_name",
            target_node_name: "target_node_name",
        };
        const rawResponseBody = {
            edge: {
                attributes: { key: "value" },
                created_at: "created_at",
                episodes: ["episodes"],
                expired_at: "expired_at",
                fact: "fact",
                invalid_at: "invalid_at",
                name: "name",
                relevance: 1.1,
                score: 1.1,
                source_node_uuid: "source_node_uuid",
                target_node_uuid: "target_node_uuid",
                uuid: "uuid",
                valid_at: "valid_at",
            },
            source_node: {
                attributes: { key: "value" },
                created_at: "created_at",
                labels: ["labels"],
                name: "name",
                relevance: 1.1,
                score: 1.1,
                summary: "summary",
                uuid: "uuid",
            },
            target_node: {
                attributes: { key: "value" },
                created_at: "created_at",
                labels: ["labels"],
                name: "name",
                relevance: 1.1,
                score: 1.1,
                summary: "summary",
                uuid: "uuid",
            },
            task_id: "task_id",
        };
        server
            .mockEndpoint()
            .post("/graph/add-fact-triple")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.graph.addFactTriple({
            fact: "fact",
            factName: "fact_name",
            sourceNodeName: "source_node_name",
            targetNodeName: "target_node_name",
        });
        expect(response).toEqual({
            edge: {
                attributes: {
                    key: "value",
                },
                createdAt: "created_at",
                episodes: ["episodes"],
                expiredAt: "expired_at",
                fact: "fact",
                invalidAt: "invalid_at",
                name: "name",
                relevance: 1.1,
                score: 1.1,
                sourceNodeUuid: "source_node_uuid",
                targetNodeUuid: "target_node_uuid",
                uuid: "uuid",
                validAt: "valid_at",
            },
            sourceNode: {
                attributes: {
                    key: "value",
                },
                createdAt: "created_at",
                labels: ["labels"],
                name: "name",
                relevance: 1.1,
                score: 1.1,
                summary: "summary",
                uuid: "uuid",
            },
            targetNode: {
                attributes: {
                    key: "value",
                },
                createdAt: "created_at",
                labels: ["labels"],
                name: "name",
                relevance: 1.1,
                score: 1.1,
                summary: "summary",
                uuid: "uuid",
            },
            taskId: "task_id",
        });
    });

    test("clone", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { graph_id: "graph_id", task_id: "task_id", user_id: "user_id" };
        server
            .mockEndpoint()
            .post("/graph/clone")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.graph.clone();
        expect(response).toEqual({
            graphId: "graph_id",
            taskId: "task_id",
            userId: "user_id",
        });
    });

    test("create", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { graph_id: "graph_id" };
        const rawResponseBody = {
            created_at: "created_at",
            description: "description",
            fact_rating_instruction: {
                examples: { high: "high", low: "low", medium: "medium" },
                instruction: "instruction",
            },
            graph_id: "graph_id",
            id: 1,
            name: "name",
            project_uuid: "project_uuid",
            uuid: "uuid",
        };
        server
            .mockEndpoint()
            .post("/graph/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.graph.create({
            graphId: "graph_id",
        });
        expect(response).toEqual({
            createdAt: "created_at",
            description: "description",
            factRatingInstruction: {
                examples: {
                    high: "high",
                    low: "low",
                    medium: "medium",
                },
                instruction: "instruction",
            },
            graphId: "graph_id",
            id: 1,
            name: "name",
            projectUuid: "project_uuid",
            uuid: "uuid",
        });
    });

    test("list_all", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            graphs: [
                {
                    created_at: "created_at",
                    description: "description",
                    graph_id: "graph_id",
                    id: 1,
                    name: "name",
                    project_uuid: "project_uuid",
                    uuid: "uuid",
                },
            ],
            row_count: 1,
            total_count: 1,
        };
        server.mockEndpoint().get("/graph/list-all").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.graph.listAll({
            pageNumber: 1,
            pageSize: 1,
        });
        expect(response).toEqual({
            graphs: [
                {
                    createdAt: "created_at",
                    description: "description",
                    graphId: "graph_id",
                    id: 1,
                    name: "name",
                    projectUuid: "project_uuid",
                    uuid: "uuid",
                },
            ],
            rowCount: 1,
            totalCount: 1,
        });
    });

    test("search", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { query: "query" };
        const rawResponseBody = {
            edges: [
                {
                    attributes: { key: "value" },
                    created_at: "created_at",
                    episodes: ["episodes"],
                    expired_at: "expired_at",
                    fact: "fact",
                    invalid_at: "invalid_at",
                    name: "name",
                    relevance: 1.1,
                    score: 1.1,
                    source_node_uuid: "source_node_uuid",
                    target_node_uuid: "target_node_uuid",
                    uuid: "uuid",
                    valid_at: "valid_at",
                },
            ],
            episodes: [
                {
                    content: "content",
                    created_at: "created_at",
                    metadata: { key: "value" },
                    processed: true,
                    relevance: 1.1,
                    role: "role",
                    role_type: "norole",
                    score: 1.1,
                    source: "text",
                    source_description: "source_description",
                    task_id: "task_id",
                    thread_id: "thread_id",
                    uuid: "uuid",
                },
            ],
            nodes: [
                {
                    attributes: { key: "value" },
                    created_at: "created_at",
                    labels: ["labels"],
                    name: "name",
                    relevance: 1.1,
                    score: 1.1,
                    summary: "summary",
                    uuid: "uuid",
                },
            ],
        };
        server
            .mockEndpoint()
            .post("/graph/search")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.graph.search({
            query: "query",
        });
        expect(response).toEqual({
            edges: [
                {
                    attributes: {
                        key: "value",
                    },
                    createdAt: "created_at",
                    episodes: ["episodes"],
                    expiredAt: "expired_at",
                    fact: "fact",
                    invalidAt: "invalid_at",
                    name: "name",
                    relevance: 1.1,
                    score: 1.1,
                    sourceNodeUuid: "source_node_uuid",
                    targetNodeUuid: "target_node_uuid",
                    uuid: "uuid",
                    validAt: "valid_at",
                },
            ],
            episodes: [
                {
                    content: "content",
                    createdAt: "created_at",
                    metadata: {
                        key: "value",
                    },
                    processed: true,
                    relevance: 1.1,
                    role: "role",
                    roleType: "norole",
                    score: 1.1,
                    source: "text",
                    sourceDescription: "source_description",
                    taskId: "task_id",
                    threadId: "thread_id",
                    uuid: "uuid",
                },
            ],
            nodes: [
                {
                    attributes: {
                        key: "value",
                    },
                    createdAt: "created_at",
                    labels: ["labels"],
                    name: "name",
                    relevance: 1.1,
                    score: 1.1,
                    summary: "summary",
                    uuid: "uuid",
                },
            ],
        });
    });

    test("get", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            created_at: "created_at",
            description: "description",
            fact_rating_instruction: {
                examples: { high: "high", low: "low", medium: "medium" },
                instruction: "instruction",
            },
            graph_id: "graph_id",
            id: 1,
            name: "name",
            project_uuid: "project_uuid",
            uuid: "uuid",
        };
        server.mockEndpoint().get("/graph/graphId").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.graph.get("graphId");
        expect(response).toEqual({
            createdAt: "created_at",
            description: "description",
            factRatingInstruction: {
                examples: {
                    high: "high",
                    low: "low",
                    medium: "medium",
                },
                instruction: "instruction",
            },
            graphId: "graph_id",
            id: 1,
            name: "name",
            projectUuid: "project_uuid",
            uuid: "uuid",
        });
    });

    test("delete", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { message: "message" };
        server.mockEndpoint().delete("/graph/graphId").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.graph.delete("graphId");
        expect(response).toEqual({
            message: "message",
        });
    });

    test("update", async () => {
        const server = mockServerPool.createServer();
        const client = new ZepClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            created_at: "created_at",
            description: "description",
            fact_rating_instruction: {
                examples: { high: "high", low: "low", medium: "medium" },
                instruction: "instruction",
            },
            graph_id: "graph_id",
            id: 1,
            name: "name",
            project_uuid: "project_uuid",
            uuid: "uuid",
        };
        server
            .mockEndpoint()
            .patch("/graph/graphId")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.graph.update("graphId");
        expect(response).toEqual({
            createdAt: "created_at",
            description: "description",
            factRatingInstruction: {
                examples: {
                    high: "high",
                    low: "low",
                    medium: "medium",
                },
                instruction: "instruction",
            },
            graphId: "graph_id",
            id: 1,
            name: "name",
            projectUuid: "project_uuid",
            uuid: "uuid",
        });
    });
});
